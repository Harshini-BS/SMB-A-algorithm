
 from queue import PriorityQueue

graph = {
    'S': [('A', 10), ('B', 8),],
    'A': [('C', 2),('G',10),('S',10)],
    'B': [('D', 8),('S',8),('G',16)],
    'C': [('E', 3), ('G', 9),('A',2)],
    'D': [('G', 3),('H',1),('B',8)],
    'E': [('G',2),('C',3)],
    'F': [('H', 1)],
    'H': [('F',1)],
    'G': [('A',10),('C',9),('E',3),('B',16),('D',3)]
}

heuristic = {
    'S': 12,
    'A': 5,
    'B': 5,
    'C': 5,
    'D': 2,
    'E': 2,
    'F': 1,
    'H':1,
    'G':0
}

MEMORY_LIMIT = 3

def sma_star_limited_memory(start, goal):
    open_set = PriorityQueue()
    memory = {}

    f_start = heuristic[start]
    open_set.put((f_start, [start], 0))  # f(n), path, g(n)
    memory[start] = f_start

    while not open_set.empty():
        f, path, g = open_set.get()
        current = path[-1]

        if current == goal:
            print("Total cost:", g)
            return path

        for neighbor, cost in graph.get(current, []):
            if neighbor not in memory:
                if len(memory) >= MEMORY_LIMIT:
                    # Remove node with highest f that is NOT in current path
                    candidates = [k for k in memory if k not in path]
                    if candidates:
                        worst_node = max(candidates, key=lambda k: memory[k])
                        del memory[worst_node]
                    else:
                        continue  # No safe node to evict

                new_g = g + cost
                new_f = new_g + heuristic[neighbor]
                new_path = path + [neighbor]
                open_set.put((new_f, new_path, new_g))
                memory[neighbor] = new_f

    return None

# Run the algorithm
result = sma_star_limited_memory('S', 'G')
print("Path found (SMA* with memory=3):", result)


OUTPUT:


Total cost: 10
Path found (SMA* with memory=3): ['S', 'C', 'G']

